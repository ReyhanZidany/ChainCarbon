// backend/scripts/verifyAndSyncBlockchainData.js

import axios from 'axios';
import mysql from 'mysql2/promise';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Setup __dirname for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load environment variables
dotenv.config({ path: join(__dirname, '../.env') });

const FABRIC_API = process.env.FABRIC_API || "http://localhost:3000";

// Database configuration
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'chaincarbon',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
};

// Create database connection pool
const pool = mysql.createPool(dbConfig);

/**
 * Main function to verify and sync blockchain data
 */
async function verifyAndSyncBlockchainData() {
  console.log("üîç Verifying and syncing blockchain data from Fabric to MySQL...\n");
  console.log("Current time:", new Date().toISOString());
  console.log("Fabric API:", FABRIC_API);
  console.log("Database:", dbConfig.database);
  console.log("=".repeat(70));

  let connection;

  try {
    // Get database connection
    connection = await pool.getConnection();
    console.log("‚úÖ Database connected\n");

    // Get all certificates
    const [certificates] = await connection.query(`
      SELECT 
        cert_id, 
        blockchain_tx_id, 
        blockchain_hash,
        blockchain_block_number,
        blockchain_timestamp,
        blockchain_revision,
        created_at,
        updated_at
      FROM certificates 
      ORDER BY created_at DESC
    `);

    console.log(`üìã Found ${certificates.length} certificates to check\n`);

    let realCount = 0;
    let fakeCount = 0;
    let nullCount = 0;
    let syncedCount = 0;
    let failedCount = 0;
    let skippedCount = 0;

    for (let i = 0; i < certificates.length; i++) {
      const cert = certificates[i];
      const progress = `[${i + 1}/${certificates.length}]`;

      console.log("\n" + "‚îÄ".repeat(70));
      console.log(`${progress} üìú Certificate: ${cert.cert_id}`);
      console.log(`   Current TX ID: ${cert.blockchain_tx_id || 'NULL'}`);
      console.log(`   Current Hash: ${cert.blockchain_hash || 'NULL'}`);
      console.log(`   Current Revision: ${cert.blockchain_revision || 'NULL'}`);

      // Check if TX ID is fake (starts with "TX-")
      const isFake = cert.blockchain_tx_id && cert.blockchain_tx_id.startsWith('TX-');
      const isNull = !cert.blockchain_tx_id;
      const hashIsFake = cert.blockchain_hash && cert.blockchain_hash.startsWith('0x');

      if (isFake) {
        console.log(`   ‚ùå Status: FAKE TX ID (Generated by system)`);
        fakeCount++;
      } else if (isNull) {
        console.log(`   ‚ö†Ô∏è  Status: NULL TX ID`);
        nullCount++;
      } else if (cert.blockchain_tx_id && cert.blockchain_tx_id.length === 64) {
        console.log(`   ‚úÖ Status: REAL TX ID (SHA256 hash)`);
        realCount++;
        
        // Check if hash is also real
        if (hashIsFake || !cert.blockchain_hash) {
          console.log(`   ‚ö†Ô∏è  Hash needs update`);
        } else if (cert.blockchain_hash && cert.blockchain_hash.length === 64) {
          console.log(`   ‚úÖ Hash is also REAL, skipping...`);
          skippedCount++;
          continue; // Skip, already has real data
        }
      }

      // Try to fetch real blockchain data from Fabric
      try {
        console.log(`\n   üîÑ Fetching from Fabric...`);
        
        const fabricRes = await axios.get(
          `${FABRIC_API}/certificates/${cert.cert_id}`,
          { 
            timeout: 5000,
            headers: { "Content-Type": "application/json" }
          }
        );

        if (fabricRes.data) {
          const fabricData = fabricRes.data;

          console.log(`   ‚úÖ Fabric response received`);
          console.log(`      _id: ${fabricData._id || 'N/A'}`);
          console.log(`      _rev: ${fabricData._rev || 'N/A'}`);

          // Extract REAL blockchain data
          const realTxId = fabricData.lastTransferTxId || 
                          fabricData.blockchainMetadata?.txId || 
                          null;
          
          const realHash = fabricData.certificateHash || null;
          const realRevision = fabricData._rev || null;
          const realTimestamp = fabricData.blockchainMetadata?.issuedAtTimestamp 
            ? new Date(fabricData.blockchainMetadata.issuedAtTimestamp)
            : null;

          console.log(`\n   üì¶ Real Blockchain Data from Fabric:`);
          console.log(`      TX ID: ${realTxId || 'N/A'}`);
          console.log(`      Hash: ${realHash || 'N/A'}`);
          console.log(`      Revision: ${realRevision || 'N/A'}`);
          console.log(`      Timestamp: ${realTimestamp?.toISOString() || 'N/A'}`);

          // Update database with REAL data
          if (realTxId || realHash) {
            await connection.query(`
              UPDATE certificates 
              SET 
                blockchain_tx_id = COALESCE(?, blockchain_tx_id),
                blockchain_hash = COALESCE(?, blockchain_hash),
                blockchain_revision = COALESCE(?, blockchain_revision),
                blockchain_timestamp = COALESCE(?, blockchain_timestamp),
                blockchain_validation_code = 0
              WHERE cert_id = ?
            `, [
              realTxId, 
              realHash, 
              realRevision,
              realTimestamp,
              cert.cert_id
            ]);

            console.log(`   ‚úÖ Updated with REAL blockchain data`);
            syncedCount++;
          } else {
            console.log(`   ‚ö†Ô∏è  No valid blockchain data in Fabric response`);
            failedCount++;
          }
        }

      } catch (fetchErr) {
        if (fetchErr.response?.status === 404) {
          console.error(`   ‚ùå Certificate not found in Fabric (404)`);
        } else if (fetchErr.code === 'ECONNREFUSED') {
          console.error(`   ‚ùå Cannot connect to Fabric API (Connection refused)`);
        } else {
          console.error(`   ‚ùå Fabric fetch failed: ${fetchErr.message}`);
        }
        failedCount++;
      }

      // Small delay to avoid overwhelming Fabric API
      await new Promise(resolve => setTimeout(resolve, 300));
    }

    console.log("\n" + "=".repeat(70));
    console.log("üìä SYNC SUMMARY:");
    console.log("=".repeat(70));
    console.log(`Total Certificates:        ${certificates.length}`);
    console.log(`‚úÖ Already Real:           ${realCount}`);
    console.log(`‚úÖ Synced to Real:         ${syncedCount}`);
    console.log(`‚úÖ Skipped (already good): ${skippedCount}`);
    console.log(`‚ùå Fake (Generated):       ${fakeCount}`);
    console.log(`‚ö†Ô∏è  NULL:                  ${nullCount}`);
    console.log(`‚ùå Failed to Sync:         ${failedCount}`);
    console.log("=".repeat(70));

    if (syncedCount > 0) {
      console.log(`\n‚úÖ SUCCESS: ${syncedCount} certificates updated with REAL blockchain data!`);
    }

    if (failedCount > 0) {
      console.log(`\n‚ö†Ô∏è  WARNING: ${failedCount} certificates failed to sync`);
      console.log(`   - Check if Fabric API is running on ${FABRIC_API}`);
      console.log(`   - Some certificates might not exist in Fabric yet`);
    }

    const stillFake = fakeCount - syncedCount;
    if (stillFake > 0) {
      console.log(`\n‚ö†Ô∏è  WARNING: ${stillFake} certificates still have FAKE data`);
      console.log(`   These need manual verification or Fabric API might be down.`);
    }

    // Show some examples of updated certificates
    if (syncedCount > 0) {
      console.log("\nüìã Example of updated certificates:");
      const [updated] = await connection.query(`
        SELECT 
          cert_id,
          LEFT(blockchain_tx_id, 16) as tx_id_preview,
          LEFT(blockchain_hash, 16) as hash_preview,
          blockchain_revision,
          CASE 
            WHEN blockchain_tx_id LIKE 'TX-%' THEN 'FAKE'
            WHEN LENGTH(blockchain_tx_id) = 64 THEN 'REAL'
            ELSE 'NULL'
          END as tx_status,
          CASE 
            WHEN blockchain_hash LIKE '0x%' THEN 'FAKE'
            WHEN LENGTH(blockchain_hash) = 64 THEN 'REAL'
            ELSE 'NULL'
          END as hash_status
        FROM certificates
        WHERE blockchain_tx_id IS NOT NULL
        ORDER BY updated_at DESC
        LIMIT 5
      `);

      console.table(updated);
    }

  } catch (error) {
    console.error("\n‚ùå Fatal error:", error.message);
    console.error(error.stack);
    process.exit(1);
  } finally {
    if (connection) {
      connection.release();
      console.log("\n‚úÖ Database connection released");
    }
    await pool.end();
    console.log("‚úÖ Database pool closed");
    console.log("\n" + "=".repeat(70));
    console.log("Script completed at:", new Date().toISOString());
    console.log("=".repeat(70));
    process.exit(0);
  }
}

// Run the script
console.log("Starting blockchain data verification and sync...\n");
verifyAndSyncBlockchainData();